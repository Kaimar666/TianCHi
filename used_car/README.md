# 一、解决方案及算法

## 1、解决方案

解决方案分为四个部分，1）数据预览；2）数据预处理；3）特征工程；4）模型调参与优化。

### 	1）数据预览

​		首先拿到数据，要看看数据的大概分布，数据的数据量、数据的特征、每个数据的类型、每个数据的分布，以方便后续对数据进行预处理和特征构造。

### 	2）数据预处理

​		此部分做了3个工作，即了解数据基本分布情况后，找出缺失值、异常值进行对应处理，并进行特征相关性分析。

​		由于选择的模型xgboost可以处理缺失值，所以对于缺失值较少的数据就不进行处理，而对缺失值很多的数据再进行处理，通过数据筛选发现缺失最多的是fuelType特征，缺8680个值，但其相比于15万的数据，属于较小缺失，所以不进行处理。

​		对于异常值，在了解了数据分布后确定了几个可能有异常值的特征，并利用箱线图分别对每个特征进行异常值筛选，设置上界和下界，将超出范围的值对应的index记录下来，添加到一个列表中，最后在原数据中根据index删除对应的数据。

​		利用特征的相关性分析，根据计算协方差等相关数据，筛选出与price相关系数绝对值大于0.5的特征，并将其他特征加入预删除列表，以备后续进行特征删除。

### 	3）特征工程

​		此部分做了4个工作，特征删除，特征构造，数据类型转换，特征选择。

​		经过上述的工作，将一些样本分布严重不均的特征和相关性较低的特征进行删除。（注意，删除时先要将训练集和测试集进行拼接，否则，最后模型生成后，测试集的输入和模型的输入不匹配，会出现问题。所以要将测试集对应的特征也进行删除，后面再拆分。）

​		由于发现creatData和regData在现实世界中构成车辆的使用时间关系，所有利用这两个特征进行特征构造。将两特征做差，换算成以day为单位的数据，生成新的特征usedTime，并删除creatData和regData两个特征。

​		经过数据预处理发现notRepairedDamage数据有object类型数据24324个，另外有两个值0和1。结合现实世界中的问题理解，决定将object数据全部赋值为2，表示不知道车辆是否有故障。从而有三个分类，即有故障、无故障和不清楚车辆故障情况。

​		对初选的特征进行特征选择，利用SequentialFeatureSelector模块，选择线性回归作为基预测器，逐一加入特征进行模型的预测分析，并选择出在最高预测分数下的特征个数，并找出对应的特征。

​		最后拆分训练集和测试集，生成对应的中间文件，以方便后续模型调参与优化。

### 	4）模型调参与优化

​		此部分做了3个工作，模型参数优化，交叉验证，模型训练与预测。

​		选择的模型是xgboost，其中对下列参数都进行了优化，现将模型设置为default值，然后进行利用网格搜索算法查找更优模型参数。

```python
		learning_rate=0.1, 		# 0.1, default=0.3
        n_estimators=1000, 		# 1000
        max_depth=10, 			# 10, default=6
        min_child_weight=2, 	# 2, default=1
        subsample=0.8, 			# 0.8, default=1
        colsample_bytree=0.9,   # 0.9, default=1
        gamma=0.7, 				# 0.7, default=0
        reg_alpha=0, 			# 0, default=0
        reg_lambda=0.1, 		# 0.1, default=1
```

​		找出上述最优的参数后，利用交叉验证算法进行模型验证，将初始的参数模型和调参后的模型进行对比，发现调参后的模型效果有明显提升。

​		最后，利用调参后的模型对测试集进行预测，并将预测结果按照对应格式生成最后的预测问价。

## 2、算法说明

​		主要使用的算法有SequentialFeatureSelector、GridSearchCV、cross_val_score和xgboost。

​		SequentialFeatureSelector算法，是用于进行特征的选择。它采用逐步加入每个特征的方式，并对没加入一个特征后计算以此模型得分，最终可得到不同特征数据量下的每个情况得分，从而可以筛选出特征数量和特征名称。

​		GridSearchCV算法，是网格搜索算法和交叉验证算法的结合，即GridSearch和CV。网格搜索按照步长以此调整参数，并结合CV进行模型验证，从而得到最有参数。

​		cross_val_score算法，是将训练集划分为不同的部分，如将cv设为5，其将训练集分为5个部分，并且用每个部分作为测试集，依次求出模型的验证误差，从而可以了解到模型的效果。

​		xgboost算法，思想是不断地添加树，进行特征分裂，然后分裂后会有一个对应的预测分数。对于不同的树，同一个东西会有不同的预测分数，最后将所有同一个东西的预测分数加起来就得到这个东西的预测分数。其核心思想是，不断添加树，不断地进行特征分类来生长一棵树，去拟合上次的预测残差，每个特征对于每棵树都有一个分数，将所有的树的对应分数加起来，就是这个特征的预测分数。

# 二、代码说明

## 1、代码运行入口

直接运行code文件夹下的main.py文件，即可完成所有工作。其中在user_data文件夹中，会生成两个处理过的中间文件，used_car_test.csv和used_car_train.csv。最终结果在prediction_result文件夹中，predictions.csv。

## 2、其他说明

若要变更测试集，需要修改feature文件夹的data_processing.py文件的第12行test_url的路径。

代码中，数据调优、数据分布查询等过程代码已经注释，只需直接运行main.py文件就能得到predictions.csv。

